{"ast":null,"code":"const Product = require('../models/ProductModel');\nconst createProduct = newProductData => {\n  return new Promise(async (resolve, reject) => {\n    const {\n      id,\n      name,\n      img,\n      type,\n      price,\n      discount,\n      description\n    } = newProductData;\n    try {\n      const checkProduct = await Product.findOne({\n        id: id\n      });\n      if (checkProduct !== null) {\n        resolve({\n          status: 'OK',\n          message: 'The name of product is already'\n        });\n      }\n      const newProduct = await Product.create({\n        id,\n        name,\n        img,\n        type,\n        price,\n        discount,\n        description\n      });\n      if (newProduct) {\n        resolve({\n          status: 'OK',\n          message: 'SUCCESS',\n          data: newProduct\n        });\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\nconst getAllProduct = (limit, page, filter, minPrice, maxPrice) => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      let match = {};\n      if (filter) {\n        match[filter[0]] = {\n          '$regex': filter[1],\n          '$options': 'i'\n        };\n      }\n\n      // let pipeline = [\n      //     { $match: match },\n      //     {\n      //         $addFields: {\n      //             effectivePrice: {\n      //                 $cond: {\n      //                     if: { $gt: [\"$discount\", 0] },  \n      //                     then: { $multiply: [\"$price\", { $subtract: [1, \"$discount\"] }] }, \n      //                     else: \"$price\" \n      //                 }\n      //             }\n      //         }\n      //     },\n      //     {\n      //         $match: {\n      //             effectivePrice: { $gte: Number(minPrice), $lte: Number(maxPrice) }\n      //         }\n      //     },\n      //     { $skip: page * limit },\n      //     { $limit: limit },\n      //     // { $project: { name: 1, price: 1, discount: 1, effectivePrice: 1, description: 1, image: 1, type: 1, countInStock: 1 } } \n      // ];\n      let pipeline = [{\n        $match: match\n      }, {\n        $addFields: {\n          effectivePrice: {\n            $cond: {\n              if: {\n                $gt: [\"$discount\", 0]\n              },\n              // Convert discount from percentage to multiplier, e.g., 20 becomes 0.8 (1 - 0.2)\n              then: {\n                $multiply: [\"$price\", {\n                  $subtract: [1, {\n                    $divide: [\"$discount\", 100]\n                  }]\n                }]\n              },\n              else: \"$price\"\n            }\n          }\n        }\n      }, {\n        $match: {\n          effectivePrice: {\n            $gte: Number(minPrice),\n            $lte: Number(maxPrice)\n          }\n        }\n      }, {\n        $skip: page * limit\n      }, {\n        $limit: limit\n      }\n      // Optional: You can add a projection to control which fields to return\n      // { $project: { name: 1, price: 1, discount: 1, effectivePrice: 1, description: 1, image: 1, type: 1, countInStock: 1 } } \n      ];\n      const products = await Product.aggregate(pipeline);\n      const totalProduct = await Product.countDocuments({\n        $and: [match, {\n          effectivePrice: {\n            $gte: Number(minPrice),\n            $lte: Number(maxPrice)\n          }\n        }]\n      });\n      resolve({\n        status: 'OK',\n        message: 'Success',\n        data: products,\n        total: totalProduct,\n        pageCurrent: Number(page) + 1,\n        totalPage: Math.ceil(totalProduct / limit)\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\nconst deleteProduct = id => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const checkProduct = await Product.findOne({\n        _id: id\n      });\n      if (checkProduct === null) {\n        resolve({\n          status: 'OK',\n          message: 'The product is not defined'\n        });\n      }\n      await Product.findByIdAndDelete(id);\n      resolve({\n        status: 'OK',\n        message: 'Delete product success'\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\nmodule.exports = {\n  createProduct,\n  getAllProduct,\n  deleteProduct\n};","map":{"version":3,"names":["Product","require","createProduct","newProductData","Promise","resolve","reject","id","name","img","type","price","discount","description","checkProduct","findOne","status","message","newProduct","create","data","e","getAllProduct","limit","page","filter","minPrice","maxPrice","match","pipeline","$match","$addFields","effectivePrice","$cond","if","$gt","then","$multiply","$subtract","$divide","else","$gte","Number","$lte","$skip","$limit","products","aggregate","totalProduct","countDocuments","$and","total","pageCurrent","totalPage","Math","ceil","deleteProduct","_id","findByIdAndDelete","module","exports"],"sources":["D:/Tu/NamIII/HKII/FE_SEARCH/src/services/ProductService.js"],"sourcesContent":["const Product = require('../models/ProductModel')\r\n\r\nconst createProduct = (newProductData) => {\r\n    return new Promise(async(resolve, reject) => {\r\n        const {id, name, img, type, price, discount, description} = newProductData\r\n        try {\r\n            const checkProduct = await Product.findOne({\r\n                id: id\r\n            })\r\n            if(checkProduct !== null)\r\n            {\r\n                resolve({\r\n                    status: 'OK',\r\n                    message: 'The name of product is already'\r\n                })\r\n            }\r\n            const newProduct = await Product.create({\r\n                id, name, img, type, price, discount, description\r\n            })\r\n            if(newProduct)\r\n            {\r\n                resolve({\r\n                    status: 'OK',\r\n                    message: 'SUCCESS',\r\n                    data: newProduct\r\n                })\r\n            }\r\n        }\r\n        catch(e) {\r\n            reject(e)\r\n        }\r\n    })\r\n}\r\n\r\nconst getAllProduct = (limit, page, filter, minPrice, maxPrice) => {\r\n    return new Promise(async (resolve, reject) => {\r\n        try {\r\n            let match = {};\r\n            if (filter) {\r\n                match[filter[0]] = {'$regex': filter[1], '$options': 'i'};\r\n            }\r\n\r\n            // let pipeline = [\r\n            //     { $match: match },\r\n            //     {\r\n            //         $addFields: {\r\n            //             effectivePrice: {\r\n            //                 $cond: {\r\n            //                     if: { $gt: [\"$discount\", 0] },  \r\n            //                     then: { $multiply: [\"$price\", { $subtract: [1, \"$discount\"] }] }, \r\n            //                     else: \"$price\" \r\n            //                 }\r\n            //             }\r\n            //         }\r\n            //     },\r\n            //     {\r\n            //         $match: {\r\n            //             effectivePrice: { $gte: Number(minPrice), $lte: Number(maxPrice) }\r\n            //         }\r\n            //     },\r\n            //     { $skip: page * limit },\r\n            //     { $limit: limit },\r\n            //     // { $project: { name: 1, price: 1, discount: 1, effectivePrice: 1, description: 1, image: 1, type: 1, countInStock: 1 } } \r\n            // ];\r\n            let pipeline = [\r\n                { $match: match },\r\n                {\r\n                    $addFields: {\r\n                        effectivePrice: {\r\n                            $cond: {\r\n                                if: { $gt: [\"$discount\", 0] },\r\n                                // Convert discount from percentage to multiplier, e.g., 20 becomes 0.8 (1 - 0.2)\r\n                                then: { $multiply: [\"$price\", { $subtract: [1, { $divide: [\"$discount\", 100] }] }] },\r\n                                else: \"$price\"\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    $match: {\r\n                        effectivePrice: { $gte: Number(minPrice), $lte: Number(maxPrice) }\r\n                    }\r\n                },\r\n                { $skip: page * limit },\r\n                { $limit: limit },\r\n                // Optional: You can add a projection to control which fields to return\r\n                // { $project: { name: 1, price: 1, discount: 1, effectivePrice: 1, description: 1, image: 1, type: 1, countInStock: 1 } } \r\n            ];\r\n\r\n            const products = await Product.aggregate(pipeline);\r\n            const totalProduct = await Product.countDocuments({ $and: [match, { effectivePrice: { $gte: Number(minPrice), $lte: Number(maxPrice) } }] });\r\n\r\n            resolve({\r\n                status: 'OK',\r\n                message: 'Success',\r\n                data: products,\r\n                total: totalProduct,\r\n                pageCurrent: Number(page) + 1,\r\n                totalPage: Math.ceil(totalProduct / limit)\r\n            });\r\n        } catch (e) {\r\n            reject(e);\r\n        }\r\n    });\r\n};\r\n\r\nconst deleteProduct = (id) => {\r\n    return new Promise(async (resolve, reject) => {\r\n        try{\r\n            const checkProduct = await Product.findOne({\r\n                _id: id\r\n            })\r\n            if(checkProduct === null)\r\n            {\r\n                resolve({\r\n                    status: 'OK',\r\n                    message: 'The product is not defined'\r\n                })\r\n            }\r\n\r\n            await Product.findByIdAndDelete(id)\r\n            resolve({\r\n                status: 'OK',\r\n                message: 'Delete product success'\r\n            })\r\n\r\n        }catch(e){\r\n            reject(e)\r\n        }\r\n    })\r\n}\r\n\r\nmodule.exports = {\r\n    createProduct,\r\n    getAllProduct,\r\n    deleteProduct\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}